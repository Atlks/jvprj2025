

🔁 一览表对比：TCC vs SAGA
维度	TCC（Try-Confirm-Cancel）	SAGA（长事务补偿）
核心思想	显式地将事务拆分为 Try / Confirm / Cancel 三个阶段	将每个操作视为一个本地事务，失败后调用补偿操作
参与者接口	每个服务需实现三套接口：Try、Confirm、Cancel	每个服务需实现两套接口：执行操作、补偿操作
强一致性	是（接近 2PC 的强一致性）	否（最终一致性）
实现难度	高：需要业务侵入，每个步骤都需定义状态	中：业务侵入较小，类似于事件驱动
典型应用场景	金融系统、支付确认、库存冻结	电商订单处理、长流程事务、非核心状态协调
失败处理	Cancel 回滚所有操作，或重试 Confirm	触发补偿流程，逆序执行补偿操作
事务粒度	细，适合短时间、需要锁定资源的事务	粗，适合长时间、不锁资源的业务
资源锁定	是（Try 阶段通常要锁定资源）	否（不会锁资源，但需要考虑业务补偿逻辑）
幂等与空回滚	必须支持幂等、空补偿、悬挂处理	只需支持幂等和补偿
常用框架支持	DTM、Seata、TCC-Transaction	DTM、Seata、Axon、Eventuate



✅ 总结建议
场景	推荐事务模式
金融支付、资金冻结、库存锁定	TCC
跨系统流程、长事务、低一致性要求	SAGA
系统已有资源锁机制	TCC
系统不支持资源锁、需高并发	SAGA