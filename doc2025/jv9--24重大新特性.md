
✅ Records（Java 14）

📌 Java 17（2021，LTS）
✅ Foreign Function访问本机代码 &
Memory API（FFM） →  直接内存访问



📌 Java 18 - 20（2022-2023）

✅ 虚拟线程（Java 19） → Thread.ofVirtual().start() 
✅ 结构化并发（Java 20） → StructuredTaskScope


FFM API 提升 2-5 倍性能 ✅ 减少 JVM 内存开销（对象数量少，GC 负担降低） ✅ 适用于高性能计算 & 大规模数据处理
📌 2. 访问本机内存
✅ MemorySegment → 直接分配和管理本机内存 ✅ 使用 MemoryAccess 读写本机数据

📌 示例代码（分配本机数组并修改数据）

java
try (Arena arena = Arena.ofConfined()) {
MemorySegment segment = arena.allocate(4); // 分配 4 字节
MemoryAccess.setInt(segment, 0, 42); // 写入数据
int value = MemoryAccess.getInt(segment, 0); // 读取数据
System.out.println("Memory Value: " + value);
}
✅ arena.allocate(size) → 分配本机内存 ✅ MemoryAccess.setInt() → 向本机内存写入数据 ✅ MemoryAccess.getInt() → 从本机内存读取数据

📌 3. 适用于
🔹 调用 C/C++ 库 → 替代 JNI，提高性能 🔹 游戏开发 & 高性能计算 → 直接访问本机内存 🔹 数据库 & 网络优化 → 处理 零拷贝 I/O

你希望在哪个场景使用 FFM API？😃