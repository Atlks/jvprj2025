aop desn



=============应用场合
感觉都可以使用anno处理了
=日志、权限控制、事务管理  全局异常 等。
=缓存（Caching）  远程调用（RPC & REST API 拦截）， 监控 & 性能统计
（Performance Monitoring）
========================aop实现方法
=模板方法模式（Template Method Pattern）
=spr模式单一职责，，，
=jdk动态代理，只能代理一个方法，其他方法需要再次调用代理，麻烦
=jvvst刚刚好。。。



AOP（面向切面编程） 的常见应用场景主要涉及 横切关注点，即那些在多个模块中重复出现的功能，比如
=============应用场合
=日志、权限控制、事务管理  全局异常 等。
=缓存（Caching）  远程调用（RPC & REST API 拦截）， 监控 & 性能统计
（Performance Monitoring）

    统计方法执行时间，排查慢查询或性能瓶颈。
    应用场景：监控 API 请求时间、分析系统性能。


缓存（Caching）

    在方法执行前检查缓存，避免重复计算。
    应用场景：数据库查询缓存、Redis 本地缓存。


远程调用（RPC & REST API 拦截）

    统一拦截 HTTP 请求或 RPC 调用，处理超时、重试、日志等逻辑。
    应用场景：Feign、Dubbo、gRPC 拦截器。


结论
应用场景	适用场合
日志记录	监控方法调用
事务管理	数据库操作
权限控制	用户权限验证
性能监控	API 性能分析
缓存	减少重复计算
远程调用	API 拦截 & 重试
异常处理	统一错误处理

========================aop实现方法
👉 你可以用 AOP 统一拦截代码，提高可维护性，减少重复逻辑！ 

=模板方法模式（Template Method Pattern）

模板方法模式 是一种 行为型设计模式，它定义了一个算法的 骨架，并允许子类在不修改结构的情况下 重写 某些步骤。
继承baseclass,,aop方法都在base。。。

模板方法模式的结构
🗂 主要角色

    抽象类（Abstract Class）
        定义算法的 基本框架（模板方法）。
        实现通用逻辑。
        声明 抽象方法 让子类实现。
    具体子类（Concrete Subclass）
        继承抽象类，实现具体步骤。

=spr模式单一职责，，，
每个功能一个service。。。注册登录分别俩个service。。。方便aop注入


=jdk动态代理，只能代理一个方法，其他方法需要再次调用代理，麻烦
cglib兼容性不能jdk21
bytebudd有bug只能俩个层次
asm太低级
=jvvst刚刚好。。。

