

维持数据一致性（Data Consistency），除了你提到的外键、约束、触发器外，还有以下这些机制可以协同工作，以保证数据不被破坏、不被脏写、并遵守预定义的业务规则：

✅ 1. 完整性约束（Integrity Constraints）
类型	说明
主键（PRIMARY KEY）	唯一标识记录，禁止空值和重复
唯一约束（UNIQUE）	限制某列或列组合不能重复
非空约束（NOT NULL）	禁止字段为 NULL
检查约束（CHECK）	限制字段的值范围或逻辑条件（如 age > 0）
外键约束（FOREIGN KEY）	强制两个表之间的引用一致性


✅ 2. 触发器（Triggers）
触发器是在 INSERT、UPDATE、DELETE 操作前/后自动执行的逻辑，用于：

日志记录

自动同步字段

实现复杂校验逻辑

阻止非法变更


✅ 3. 事务（Transactions）
事务通过四大特性（ACID）来保证一致性：

A（Atomicity）原子性：要么全部成功，要么全部失败

C（Consistency）一致性：操作前后数据满足约束

I（Isolation）隔离性：事务之间互不干扰（详见隔离级别）

D（Durability）持久性：提交后的数据永久保存


✅ 5. 写前日志（Write-Ahead Logging, WAL）
在数据变更前先写入日志，用于：

崩溃恢复

保证原子性与持久性
（如 PostgreSQL、SQLite 默认使用）

✅ 6. 乐观锁 / 悲观锁
乐观锁：使用版本号字段控制并发更新（无锁）

悲观锁：使用 SELECT FOR UPDATE 锁住记录防止并发冲突

✅ 7. 视图与物化视图
视图（View）：逻辑上封装查询，只读，用于防止复杂查询误操作。

物化视图：可定时更新的缓存表，适合统计场景。

✅ 8. 存储过程 / 函数
将业务逻辑封装在数据库内部，以统一数据操作方式，降低错误操作。

✅ 9. 表结构设计规范
第三范式（3NF）或更高范式，避免数据冗余和更新异常

分表分区避免写入热点和数据冲突

✅ 10. 数据校验与审计机制
比如定期对账、hash 校验字段、双写验证机制等